"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ui_1 = require("@sanity/ui");
var react_1 = __importStar(require("react"));
var react_redux_1 = require("react-redux");
var react_virtualized_auto_sizer_1 = __importDefault(require("react-virtualized-auto-sizer"));
var react_window_infinite_loader_1 = __importDefault(require("react-window-infinite-loader"));
var constants_1 = require("../../constants");
var useBreakpointIndex_1 = __importDefault(require("../../hooks/useBreakpointIndex"));
var useTypedSelector_1 = __importDefault(require("../../hooks/useTypedSelector"));
var assets_1 = require("../../modules/assets");
var selectors_1 = require("../../modules/selectors");
var tags_1 = require("../../modules/tags");
var Cards_1 = __importDefault(require("../Cards"));
var Table_1 = __importDefault(require("../Table"));
var Items = function () {
    // Redux
    var dispatch = react_redux_1.useDispatch();
    var fetchCount = useTypedSelector_1.default(function (state) { return state.assets.fetchCount; });
    var fetching = useTypedSelector_1.default(function (state) { return state.assets.fetching; });
    var pageSize = useTypedSelector_1.default(function (state) { return state.assets.pageSize; });
    var tagsPanelVisible = useTypedSelector_1.default(function (state) { return state.tags.panelVisible; });
    var view = useTypedSelector_1.default(function (state) { return state.assets.view; });
    var itemIds = useTypedSelector_1.default(function (state) { return state.assets.allIds; });
    var pickedCount = useTypedSelector_1.default(assets_1.selectAssetsPickedLength);
    var combinedItems = useTypedSelector_1.default(selectors_1.selectCombinedItems);
    var breakpointIndex = useBreakpointIndex_1.default();
    // const hasFetchedOnce = totalCount >= 0
    var hasFetchedOnce = fetchCount >= 0;
    var hasItems = combinedItems.length > 0;
    // Every row is loaded except for our loading indicator row.
    var isItemLoaded = function (index) {
        return index < itemIds.length;
    };
    // Only load 1 page of items at a time.
    // Pass an empty callback to InfiniteLoader in case it asks us to load more than once.
    var handleLoadMoreItems = function () {
        if (!fetching) {
            dispatch(assets_1.assetsActions.loadNextPage());
        }
        return new Promise(function () { });
    };
    // Effects
    // - Hide tag panel on smaller breakpoints
    react_1.useEffect(function () {
        if (breakpointIndex <= 1 && tagsPanelVisible) {
            dispatch(tags_1.tagsActions.panelVisibleSet({ panelVisible: false }));
        }
    }, [breakpointIndex]);
    // NOTE: The below is a workaround and can be inaccurate in certain cases.
    // e.g. if `pageSize` is 10 and you have fetched 10 items, `hasMore` will still be true
    // and another fetch will invoked on next page (which will return 0 items).
    // This is currently how the default asset source in Sanity works.
    // TODO: When it's performant enough to get total asset count across large datasets, revert
    // to using `totalCount` across the board.
    var hasMore = fetchCount === pageSize;
    // const hasMore = (pageIndex + 1) * pageSize < totalCount
    // If there are more items to be loaded then add an extra placeholder row to trigger additional page loads.
    var itemCount = hasMore ? itemIds.length + 1 : itemIds.length;
    var isEmpty = !hasItems && hasFetchedOnce && !fetching;
    return (react_1.default.createElement(ui_1.Box, { flex: 1, style: {
            height: '100%',
            left: 0,
            position: 'absolute',
            top: 0,
            width: '100%'
        } },
        isEmpty && (react_1.default.createElement(ui_1.Box, { padding: 4 },
            react_1.default.createElement(ui_1.Text, { size: 1, weight: "semibold" }, "No results for the current query"))),
        !isEmpty && (view === 'grid' || 'table') && (react_1.default.createElement(react_virtualized_auto_sizer_1.default, { style: { marginTop: pickedCount > 0 ? constants_1.PANEL_HEIGHT : 0 } }, function (_a) {
            var height = _a.height, width = _a.width;
            var containerHeight = pickedCount > 0 ? height - constants_1.PANEL_HEIGHT : height;
            // TODO: double check itemCount usage with InfiniteLoader + uploads
            return (react_1.default.createElement(react_window_infinite_loader_1.default, { isItemLoaded: isItemLoaded, itemCount: itemCount, loadMoreItems: handleLoadMoreItems }, function (_a) {
                var onItemsRendered = _a.onItemsRendered, ref = _a.ref;
                // View: Table
                if (view === 'table') {
                    return (react_1.default.createElement(Table_1.default, { height: containerHeight, items: combinedItems, onItemsRendered: onItemsRendered, ref: ref, width: width }));
                }
                // View: Grid
                if (view === 'grid') {
                    // The `onItemsRendered` method signature for `react-window` grids is different and
                    // requires an adaptor, below.
                    // Source: https://github.com/bvaughn/react-window-infinite-loader/issues/3
                    var newItemsRendered = function (gridData) {
                        var overscanRowStartIndex = gridData.overscanRowStartIndex, overscanRowStopIndex = gridData.overscanRowStopIndex, overscanColumnStopIndex = gridData.overscanColumnStopIndex;
                        var endCol = overscanColumnStopIndex + 1;
                        var startRow = overscanRowStartIndex;
                        var endRow = overscanRowStopIndex;
                        var visibleStartIndex = startRow * endCol;
                        var visibleStopIndex = endRow * endCol;
                        onItemsRendered({
                            overscanStartIndex: visibleStartIndex - 10,
                            overscanStopIndex: visibleStopIndex + 10,
                            visibleStartIndex: visibleStartIndex,
                            visibleStopIndex: visibleStopIndex
                        });
                    };
                    return (react_1.default.createElement(Cards_1.default, { height: containerHeight, items: combinedItems, onItemsRendered: newItemsRendered, ref: ref, width: width }));
                }
            }));
        }))));
};
exports.default = Items;
//# sourceMappingURL=index.js.map