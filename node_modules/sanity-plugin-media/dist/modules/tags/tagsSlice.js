"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRequest = exports.updateError = exports.updateComplete = exports.sort = exports.panelVisibleSet = exports.listenerUpdateQueue = exports.listenerUpdateComplete = exports.listenerDeleteQueue = exports.listenerDeleteComplete = exports.listenerCreateQueue = exports.listenerCreateComplete = exports.fetchRequest = exports.fetchError = exports.fetchComplete = exports.deleteRequest = exports.deleteError = exports.deleteComplete = exports.createRequest = exports.createError = exports.createComplete = exports.selectTagSelectOptions = exports.selectTagById = exports.selectTags = exports.tagsUpdateEpic = exports.tagsSortEpic = exports.tagsListenerUpdateQueueEpic = exports.tagsListenerDeleteQueueEpic = exports.tagsListenerCreateQueueEpic = exports.tagsFetchEpic = exports.tagsDeleteEpic = exports.tagsCreateEpic = void 0;
var toolkit_1 = require("@reduxjs/toolkit");
var groq_1 = __importDefault(require("groq"));
var client_1 = __importDefault(require("part:@sanity/base/client"));
var redux_observable_1 = require("redux-observable");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var constants_1 = require("../../constants");
var assets_1 = require("../assets");
var dialog_1 = require("../dialog");
var checkTagName_1 = __importDefault(require("../../operators/checkTagName"));
var debugThrottle_1 = __importDefault(require("../../operators/debugThrottle"));
var getTagSelectOptions_1 = __importDefault(require("../../utils/getTagSelectOptions"));
var initialState = {
    allIds: [],
    byIds: {},
    creating: false,
    creatingError: undefined,
    fetchCount: -1,
    fetching: false,
    fetchingError: undefined,
    panelVisible: true
};
var tagsSlice = toolkit_1.createSlice({
    name: 'tags',
    initialState: initialState,
    extraReducers: function (builder) {
        builder
            .addCase(dialog_1.showTagCreate, function (state) {
            delete state.creatingError;
        })
            .addCase(dialog_1.showTagEdit, function (state, action) {
            var tagId = action.payload.tagId;
            delete state.byIds[tagId].error;
        })
            // TODO: double check matcher
            .addMatcher(function (action) {
            return [
                assets_1.tagsAddComplete.type,
                assets_1.tagsAddError.type,
                assets_1.tagsRemoveComplete.type,
                assets_1.tagsRemoveError.type
            ].includes(action.type);
        }, function (state, action) {
            console.log('add/remove error/complete');
            var tag = action.payload.tag;
            state.byIds[tag._id].updating = false;
        })
            // TODO: double check matcher
            .addMatcher(function (action) {
            return [
                assets_1.tagsAddRequest.type,
                assets_1.tagsRemoveRequest.type
            ].includes(action.type);
        }, function (state, action) {
            console.log('add/remove request');
            var tag = action.payload.tag;
            state.byIds[tag._id].updating = true;
        });
        /*
              case AssetsActionTypes.TAGS_ADD_COMPLETE:
          case AssetsActionTypes.TAGS_REMOVE_COMPLETE: {
            const {tag} = action.payload
            draft.byIds[tag._id].updating = false
            break
          }
    
          case AssetsActionTypes.TAGS_ADD_ERROR:
          case AssetsActionTypes.TAGS_REMOVE_ERROR: {
            const {tag} = action.payload
            draft.byIds[tag._id].updating = false
            break
          }
    
          case AssetsActionTypes.TAGS_ADD_REQUEST:
          case AssetsActionTypes.TAGS_REMOVE_REQUEST: {
            const {tag} = action.payload
            draft.byIds[tag._id].updating = true
            break
          }
        */
    },
    reducers: {
        createComplete: function (state, action) {
            state.creating = false;
        },
        createError: function (state, action) {
            state.creating = false;
            state.creatingError = action.payload.error;
        },
        createRequest: function (state, action) {
            state.creating = true;
            delete state.creatingError;
        },
        deleteComplete: function (state, action) {
            var _a;
            var tagId = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.tagId;
            var deleteIndex = state.allIds.indexOf(tagId);
            if (deleteIndex >= 0) {
                state.allIds.splice(deleteIndex, 1);
            }
            delete state.byIds[tagId];
        },
        deleteError: function (state, action) {
            var _a = action.payload, error = _a.error, tag = _a.tag;
            var tagId = tag === null || tag === void 0 ? void 0 : tag._id;
            state.byIds[tagId].error = error;
            state.byIds[tagId].updating = false;
        },
        deleteRequest: function (state, action) {
            var _a, _b;
            var tagId = (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.tag) === null || _b === void 0 ? void 0 : _b._id;
            state.byIds[tagId].picked = false;
            state.byIds[tagId].updating = true;
            Object.keys(state.byIds).forEach(function (key) {
                delete state.byIds[key].error;
            });
        },
        fetchComplete: function (state, action) {
            var _a;
            var tags = ((_a = action.payload) === null || _a === void 0 ? void 0 : _a.tags) || [];
            if (tags) {
                tags.forEach(function (tag) {
                    state.allIds.push(tag._id);
                    state.byIds[tag._id] = {
                        picked: false,
                        tag: tag,
                        updating: false
                    };
                });
            }
            state.fetching = false;
            state.fetchCount = tags.length || 0;
            delete state.fetchingError;
        },
        fetchError: function (state, action) {
            state.fetching = false;
            state.fetchingError = action.payload.error;
        },
        fetchRequest: {
            reducer: function (state, action) {
                state.fetching = true;
                delete state.fetchingError;
            },
            prepare: function () {
                // Construct query
                var query = groq_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          {\n            \"items\": *[\n              _type == \"", "\"\n              && !(_id in path(\"drafts.**\"))\n            ] {\n              _createdAt,\n              _updatedAt,\n              _id,\n              _rev,\n              _type,\n              name\n            } | order(name.current asc),\n          }\n        "], ["\n          {\n            \"items\": *[\n              _type == \"", "\"\n              && !(_id in path(\"drafts.**\"))\n            ] {\n              _createdAt,\n              _updatedAt,\n              _id,\n              _rev,\n              _type,\n              name\n            } | order(name.current asc),\n          }\n        "])), constants_1.TAG_DOCUMENT_NAME);
                return { payload: { query: query } };
            }
        },
        // Apply created tags (via sanity real-time events)
        // TODO: rename to something that includes 'batched' or similar
        listenerCreateComplete: function (state, action) {
            var tags = action.payload.tags;
            tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
                // Add normalised tag item
                state.byIds[tag._id] = {
                    picked: false,
                    tag: tag,
                    updating: false
                };
                // Add tag ID
                state.allIds.push(tag._id);
            });
        },
        // Queue batch tag creation
        listenerCreateQueue: function (state, action) {
            //
        },
        // Apply deleted tags (via sanity real-time events)
        // TODO: rename to something that includes 'batched' or similar
        listenerDeleteComplete: function (state, action) {
            var tagIds = action.payload.tagIds;
            tagIds === null || tagIds === void 0 ? void 0 : tagIds.forEach(function (tagId) {
                var deleteIndex = state.allIds.indexOf(tagId);
                if (deleteIndex >= 0) {
                    state.allIds.splice(deleteIndex, 1);
                }
                delete state.byIds[tagId];
            });
        },
        // Queue batch tag deletion
        listenerDeleteQueue: function (state, action) {
            //
        },
        // Apply updated tags (via sanity real-time events)
        // TODO: rename to something that includes 'batched' or similar
        listenerUpdateComplete: function (state, action) {
            var tags = action.payload.tags;
            tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
                if (state.byIds[tag._id]) {
                    state.byIds[tag._id].tag = tag;
                }
            });
        },
        // Queue batch tag updates
        listenerUpdateQueue: function (state, action) {
            //
        },
        // Set tag panel visibility
        panelVisibleSet: function (state, action) {
            var _a;
            state.panelVisible = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.panelVisible;
        },
        // Sort all tags by name
        sort: function (state) {
            state.allIds.sort(function (a, b) {
                var tagA = state.byIds[a].tag.name.current;
                var tagB = state.byIds[b].tag.name.current;
                if (tagA < tagB) {
                    return -1;
                }
                else if (tagA > tagB) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
        },
        updateComplete: function (state, action) {
            var _a;
            var tagId = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.tagId;
            state.byIds[tagId].updating = false;
        },
        updateError: function (state, action) {
            var _a = action.payload, error = _a.error, tag = _a.tag;
            var tagId = tag === null || tag === void 0 ? void 0 : tag._id;
            state.byIds[tagId].error = error;
            state.byIds[tagId].updating = false;
        },
        updateRequest: function (state, action) {
            var _a, _b;
            var tagId = (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.tag) === null || _b === void 0 ? void 0 : _b._id;
            state.byIds[tagId].updating = true;
        }
    }
});
// On tag create request:
// - async check to see if tag already exists
// - throw if tag already exists
// - otherwise, create new tag
var tagsCreateEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.createRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var action = _a[0], state = _a[1];
        var _b = action.payload, assetId = _b.assetId, name = _b.name;
        return rxjs_1.of(action).pipe(debugThrottle_1.default(state.debug.badConnection), checkTagName_1.default(name), operators_1.mergeMap(function () {
            return rxjs_1.from(client_1.default.create({
                _type: constants_1.TAG_DOCUMENT_NAME,
                name: {
                    _type: 'slug',
                    current: name
                }
            }));
        }), operators_1.mergeMap(function (result) { return rxjs_1.of(tagsSlice.actions.createComplete({ assetId: assetId, tag: result })); }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.createError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                name: name
            }));
        }));
    }));
};
exports.tagsCreateEpic = tagsCreateEpic;
// On tag delete request
// - find referenced assets
// - remove tag from referenced assets in a sanity transaction
var tagsDeleteEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.deleteRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var action = _a[0], state = _a[1];
        var tag = action.payload.tag;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Fetch assets which reference this tag
        operators_1.mergeMap(function () {
            return rxjs_1.from(client_1.default.fetch(groq_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["*[\n                _type in [\"sanity.fileAsset\", \"sanity.imageAsset\"]\n                && references(*[_type == \"media.tag\" && name.current == $tagName]._id)\n              ] {\n                _id,\n                _rev,\n                opt\n              }"], ["*[\n                _type in [\"sanity.fileAsset\", \"sanity.imageAsset\"]\n                && references(*[_type == \"media.tag\" && name.current == $tagName]._id)\n              ] {\n                _id,\n                _rev,\n                opt\n              }"]))), { tagName: tag.name.current }));
        }), 
        // Create transaction which remove tag references from all matched assets and delete tag
        operators_1.mergeMap(function (assets) {
            var patches = assets.map(function (asset) { return ({
                id: asset._id,
                patch: {
                    // this will cause the transaction to fail if the document has been modified since it was fetched.
                    ifRevisionID: asset._rev,
                    unset: ["opt.media.tags[_ref == \"" + tag._id + "\"]"]
                }
            }); });
            var transaction = patches.reduce(function (transaction, patch) { return transaction.patch(patch.id, patch.patch); }, client_1.default.transaction());
            transaction.delete(tag._id);
            return rxjs_1.from(transaction.commit());
        }), 
        // Dispatch complete action
        operators_1.mergeMap(function () { return rxjs_1.of(tagsSlice.actions.deleteComplete({ tagId: tag._id })); }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.deleteError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                tag: tag
            }));
        }));
    }));
};
exports.tagsDeleteEpic = tagsDeleteEpic;
// Async fetch tags
var tagsFetchEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.fetchRequest.match), operators_1.withLatestFrom(state$), operators_1.switchMap(function (_a) {
        var _b;
        var action = _a[0], state = _a[1];
        var query = (_b = action.payload) === null || _b === void 0 ? void 0 : _b.query;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Fetch tags
        operators_1.mergeMap(function () { return rxjs_1.from(client_1.default.fetch(query)); }), 
        // Dispatch complete action
        operators_1.mergeMap(function (result) {
            var items = result.items;
            return rxjs_1.of(tagsSlice.actions.fetchComplete({ tags: items }));
        }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.fetchError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                }
            }));
        }));
    }));
};
exports.tagsFetchEpic = tagsFetchEpic;
// TODO: merge all buffer epics
// Buffer tag creation via sanity subscriber
var tagsListenerCreateQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerCreateQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.switchMap(function (actions) {
        var tags = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tag; });
        return rxjs_1.of(tagsSlice.actions.listenerCreateComplete({ tags: tags }));
    }));
};
exports.tagsListenerCreateQueueEpic = tagsListenerCreateQueueEpic;
// TODO: merge all buffer epics
// Buffer tag deletion via sanity subscriber
var tagsListenerDeleteQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerDeleteQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.switchMap(function (actions) {
        var tagIds = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tagId; });
        return rxjs_1.of(tagsSlice.actions.listenerDeleteComplete({ tagIds: tagIds }));
    }));
};
exports.tagsListenerDeleteQueueEpic = tagsListenerDeleteQueueEpic;
// TODO: merge all buffer epics
// Buffer tag update via sanity subscriber
var tagsListenerUpdateQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerUpdateQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.switchMap(function (actions) {
        var tags = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tag; });
        return rxjs_1.of(tagsSlice.actions.listenerUpdateComplete({ tags: tags }));
    }));
};
exports.tagsListenerUpdateQueueEpic = tagsListenerUpdateQueueEpic;
// On successful tag creation or updates:
// - Re-sort all tags
var tagsSortEpic = function (action$) {
    return action$.pipe(redux_observable_1.ofType(tagsSlice.actions.listenerCreateComplete.type, tagsSlice.actions.listenerUpdateComplete.type), operators_1.bufferTime(1000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.switchMap(function () {
        return rxjs_1.of(tagsSlice.actions.sort());
    }));
};
exports.tagsSortEpic = tagsSortEpic;
// On tag update request
// - check if tag name already exists
// - throw if tag already exists
// - otherwise, patch document
var tagsUpdateEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.updateRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b;
        var action = _a[0], state = _a[1];
        var _c = action.payload, closeDialogId = _c.closeDialogId, formData = _c.formData, tag = _c.tag;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Check if tag name is available, throw early if not
        checkTagName_1.default((_b = formData === null || formData === void 0 ? void 0 : formData.name) === null || _b === void 0 ? void 0 : _b.current), 
        // Patch document (Update tag)
        operators_1.mergeMap(function () {
            return rxjs_1.from(client_1.default
                .patch(tag._id)
                .set({ name: { _type: 'slug', current: formData === null || formData === void 0 ? void 0 : formData.name.current } })
                .commit());
        }), 
        // Dispatch complete action
        operators_1.mergeMap(function (updatedTag) {
            return rxjs_1.of(tagsSlice.actions.updateComplete({
                closeDialogId: closeDialogId,
                tagId: updatedTag._id
            }));
        }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.updateError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                tag: tag
            }));
        }));
    }));
};
exports.tagsUpdateEpic = tagsUpdateEpic;
// Selectors
var selectTagsByIds = function (state) { return state.tags.byIds; };
var selectTagsAllIds = function (state) { return state.tags.allIds; };
exports.selectTags = toolkit_1.createSelector([selectTagsByIds, selectTagsAllIds], function (byIds, allIds) { return allIds.map(function (id) { return byIds[id]; }); });
exports.selectTagById = toolkit_1.createSelector([selectTagsByIds, function (_state, tagId) { return tagId; }], function (byIds, tagId) { return byIds[tagId]; });
// TODO: use createSelector
// Map tag references to react-select options, skipping over items with no linked tags
var selectTagSelectOptions = function (asset) { return function (state) {
    var _a, _b, _c;
    var tags = (_c = (_b = (_a = asset === null || asset === void 0 ? void 0 : asset.opt) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.tags) === null || _c === void 0 ? void 0 : _c.reduce(function (acc, v) {
        var tagItem = state.tags.byIds[v._ref];
        if (tagItem === null || tagItem === void 0 ? void 0 : tagItem.tag) {
            acc.push(tagItem);
        }
        return acc;
    }, []);
    if (tags && (tags === null || tags === void 0 ? void 0 : tags.length) > 0) {
        return getTagSelectOptions_1.default(tags);
    }
    return null;
}; };
exports.selectTagSelectOptions = selectTagSelectOptions;
exports.createComplete = (_a = tagsSlice.actions, _a.createComplete), exports.createError = _a.createError, exports.createRequest = _a.createRequest, exports.deleteComplete = _a.deleteComplete, exports.deleteError = _a.deleteError, exports.deleteRequest = _a.deleteRequest, exports.fetchComplete = _a.fetchComplete, exports.fetchError = _a.fetchError, exports.fetchRequest = _a.fetchRequest, exports.listenerCreateComplete = _a.listenerCreateComplete, exports.listenerCreateQueue = _a.listenerCreateQueue, exports.listenerDeleteComplete = _a.listenerDeleteComplete, exports.listenerDeleteQueue = _a.listenerDeleteQueue, exports.listenerUpdateComplete = _a.listenerUpdateComplete, exports.listenerUpdateQueue = _a.listenerUpdateQueue, exports.panelVisibleSet = _a.panelVisibleSet, exports.sort = _a.sort, exports.updateComplete = _a.updateComplete, exports.updateError = _a.updateError, exports.updateRequest = _a.updateRequest;
exports.default = tagsSlice.reducer;
var templateObject_1, templateObject_2;
